{\rtf1\ansi\ansicpg1252\cocoartf1138
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural

\f0\fs24 \cf0 Dex is short for Dalvik Executable\
\
Low memory\
Relatively low RAM\
No swap\
Powered by battery\
\
Equal to 10 year old computer (i.e. 1998)\
\
64 MB of RAM\
40 MB by OS, drivers, etc.\
20 MB\
10 MB - system library\
~10 MB left for apps\
\
Security relies on process separation\
\
10:00 - good size information\
\
10:00+ - starts memory discussion\
clean vs dirty\
clean - mmap and unwritten\
dirty - malloc-ed\
\
shared vs dirty\
shared - used by many processes\
private - used only by one process\
\
DEX files are memory mapped into Dalvik\
\
13:30 - Zygote\
\
See if can find the socket that Zygote listens on\
Appears to be 666 (but need to verify / demonstrate that)\
\
16:30 - little GC info on mark bits\
\
19:00\
250-500 MhZ\
100 MhZ bus\
16-32K cache\
20 MB available RAM\
\
20:00\
No JIT in Android 1.0\
Avoid memory pressure\
Native code / custom hardware can handle the heavy lifting\
\
22:20\
DEX-es are verified at install time\
Optimization\
- byte swapping and padding\
- static linking\
- "inlining" special native mehods\
- pruning empty methods\
- adding auxiliary data\
\
Useful for avoiding overhead of java.lang.Object constructor\
\
25:30 - Register Machine\
Code is more dense\
30% fewer instructions\
35% fewer code units\
35% more bytes (but consume 2 at a time)\
\
27:00 - For loop comparison\
JVM\
- 25 bytes\
- 14 dispatches\
- 45 reads\
- 16 writes\
Can save 6 reads / writes with fancier interpreter\
\
Dalvik\
- 18 bytes\
-   6 dispatches\
- 19 reads\
-   6 writes\
\
28:30 - Array example\
11 bytes per element\
nop spacer\
\
32:00 - Brief Interpreter Intro\
Naive interpreter - 4 branches per dispatch\
GCC has computed goto to counteract the dispatch overhead\
Same thing in assembly can reduce the number of memory reads\
For read efficiency, some op-codes are padded\
Each op-code can be aligned on a cache line boundary\
\
37:30 - Time Scales - Human vs Computer\
Well-behaved app should sleep often\
\
40:00 - Loop efficiency - good fodder for benchmark}