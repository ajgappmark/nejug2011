{\rtf1\ansi\ansicpg1252\cocoartf1138
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww14400\viewh9360\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural

\f0\fs24 \cf0 JVM Mains\
	dalvikvm/Main.c - main VM entry point\
	dexdump/DexDump.c - Dex mimic of objdump\
	dexlist/DexList.c - list DEX contents\
	dexopt/OptMain - DEX optimizer\
\
dalvikvm/Main.c - main - key activities\
	JNI_CreateJavaVM( &vm, &env, &initArgs )\
	startClass = (*env)->FindClass( env, slashClass );\
	startMeth = (*env)->GetSTaticMethodID(\
		env,\
		startClass,\
		"main",\
		"([Ljava/lang/String;)V" );\
	(*env)->CallStaticVoid(\
		env,\
		startClass,\
		startMeth,\
		strArray );\
\
vm/alloc/Alloc.h\
	dvmGcStartup\
	dvmCreateStockExceptions\
	dvmGcStartupAfterZygote\
	dvmGcThreadShutdown\
	dvmGcPreZygoteFork\
	dvmMalloc\
	dvmAllocObject\
	dvmThrowBadAllocException\
	dvmAddTackedAlloc\
	dvmReleaseTrackedAlloc\
	dvmIsValidObject\
	dvmCloneObject\
	dvmValidateObject\
	dvmObjectSizeInHeap\
	dvmGetTargetHeapUtilization\
	dvmMinimumHeapSize\
	dvmTrackExternalAllocation\
	dvmTrackExternalFree\
	dvmGetExternalBytesAllocated\
	dvmCountInstancesOfClass\
	dvmCountAssignableInstanceOfClass\
\
vm/alloc/CardTable.h\
	dvmCardTableStartup\
	dvmCardTableShutdown\
	dvmClearCardTable\
	dvmCardFromAddr\
	dvmAddrFromCard\
	dvmMarkCard\
\
vm/alloc/DdmHeap.h\
	dvmDdmSendHeapInfo\
	dvmDdmSendHeapSegments\
\
vm/alloc/GC.h\
	dvmCollectGarbage\
	dvmMarkObjectNonNull\
	dvmMarkObject\
	dvmMarkIfObject\
	dvmGcScanRootClassLoader\
	dvmGcScanRootThreadGroups\
	dvmGcScanInternedStrings\
	dvmGcDetachedDeadInternedStrings\
	dvmGcScanPrimitiveClasses\
	dvmGcMarkJniGlobalRefs\
	dvmGcMarkDebuggerRefs\
	HPROF_SET_GC_SCAN_STATE - defined differently based on HPROF support\
		calls dvmHeapSetHprofGcScanState with differing arguments\
	HPROF_CLEAR_GC_SCAN_STATE - defined differently based on HPROF support\
\
vm/alloc/Heap.h\
	dvmHeapStartup\
	dvmHeapStartupAfterZygote\
	dvmHeapShutdown\
	dvmHeapThreadShutdown\
	dvmObjectSizeInHeap\
	dvmCollectGarbageInternal\
	dvmWaitForConcurrentGcToComplete\
\
vm/compiler\
	From the code, the JIT appears to go through a MIR (mid-level) and LIR (low-level)\
	MIR appears to be SSA\
	MIR can be found \
\
vm/compiler/Dataflow.c\
	contains an array of bit fields - that provides metadata about each byte code instruction (presumably used by the JIT optimizer)\
\
Zygote appears to be exposed as dalvik.system.Zygote to Java code}